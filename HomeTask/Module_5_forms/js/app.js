// // 1 
// // Метод push добавляет неограниченное количество элементов в конец массива. При этом исходный массив изменяется, а результатом возвращается новая длина массива.

// let sports = ['хоккей', 'бег'];
// let sportsPlus = sports.push('акробатика', 'скалолазание');

// console.log(sports); // хоккей бег акробатика скалолазание
// console.log(sportsPlus);  // 4 выводит количество элементов

// for(sportNumber = 1; sportNumber <=5; sportNumber++)
// {
//     sports.push(sportNumber) 
// }
// console.log(sports); // хоккей бег акробатика скалолазание 1 2 3 4 5

// // 2 
// // Метод pop удаляет последний элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный элемент.

// let alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.pop();
// console.log(alphabet); // a b c d

// let unDel = alphabet.pop();
// console.log(unDel); // возврат удаленного элемента: d


// // 3 
// // Метод slice вырезает и возвращает указанную часть массива.
// // Первым параметром указывается номер элемента массива, с которого начинается вырезание, а вторым параметром - номер элемента, на котором закончится вырезание (при этом элемент с этим номером не включится в вырезанную часть).
// // Второй параметр не является обязательным. Если его не указать - подмассив возьмется с указанного в первом параметре элемента до конца массива.
// // Второй параметр также может принимать отрицательные значения. В этом случае отсчет элемента, на котором закончится обрезание, начинается с конца массива. Причем, последний элемент имеет номер -1, предпоследний -2 и так далее.
// // К примеру, если написать slice(1, -1), то вырезанная часть возьмется с первого элемента включительно по последний не включая его. Если вам нужно включить и последний элемент - нужно просто не задавать второй параметр для slice, вот так: slice(1).
// //mМетод не изменяет исходный массив.
// // Важно: нумерация элементов начинается с нуля.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// del = alphabet.slice(0, 2); //вырежет первые два
// console.log(del); // a b 

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// del = alphabet.slice(3); // удалит первые три
// console.log(del); // d e 

// alphabet = ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j'];
// del = alphabet.slice(3, -3);
// console.log(del); // d f g


// // 4 
// // Метод splice удаляет или добавляет элементы в массив. Можно только удалять элементы, только добавлять или делать и то и другое одновременно. 
// // Метод изменяет сам массив и возвращает при этом массив удаленных элементов.
// // Первым параметром метод принимает номер элемента массива, который нужно удалить. Вторым параметром - сколько элементов массива следует удалить. Если его поставить в 0 - то элементы удалены не будут (только добавлены новые).
// // Дальше через запятую идут элементы, которые нужно добавить в массив (являются необязательными параметрами). Эти элементы добавятся вместо удаленных элементов массива.
// // Если удаления не было (когда второй параметр 0) - элементы вставятся в массив начиная с той позиции, которая указана первым параметром метода.
// // Первый параметр может иметь отрицательное значение. В этом случае отсчет позиции начнется не с начала массива, а с конца. Причем, последний элемент имеет номер -1, предпоследний -2 и так далее.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.splice(1, 3);
// console.log(alphabet); // a e

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.splice(2, 1, '1', '2', '3');
// console.log(alphabet); // a b 1 2 3 d e

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.splice(2, 0, '1', '2', '3');
// console.log(alphabet); // a b 1 2 3 c d e


// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.splice(-2, 1);
// console.log(alphabet); // a b c e


// // 5 
// // Метод shift удаляет первый элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный элемент.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.shift();
// console.log(alphabet); // b c d e
// unDel = alphabet.shift();
// console.log(unDel); // b возвращает удаленный элемент


// // 6 
// // Метод unshift добавляет неограниченное количество новых элементов в начало массива. При этом исходный массив изменяется, а результатом возвращается новая длина массива.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// alphabet.unshift('1', '2');
// console.log(alphabet); // 1 2 a b c d e

// let length = alphabet.unshift();
// console.log(length); // выводит количество элементов: 7 


// // 7 
// // Метод join объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива).
// // Разделитель задается параметром метода и не является обязательным. Если он не задан - по умолчанию в качестве разделителя возьмется запятая. Если вы хотите слить элементы массива без разделителя - укажите его как пустую строку ''.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// let dash = alphabet.join(' -=+=- ' + sports + '\n'); // разделить можно как угодно
// console.log(dash);

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// let alphabetRevers = alphabet.join('').split('').reverse().join(''); // объединил, снова разделил, реверснул, снова объединил... можно было и без первых двух методов обойтись)
// console.log(alphabetRevers); // edcba


// // 8 
// // Метод indexOf() сравнивает искомый элемент searchElement с элементами в массиве, используя строгое сравнение (en-US) (тот же метод используется оператором ===, тройное равно).

// // Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.

// // Индекс, с которого начинать поиск. Если индекс больше или равен длине массива, возвращается -1, что означает, что массив даже не просматривается. Если индекс является отрицательным числом, он трактуется как смещение с конца массива. Обратите внимание: если индекс отрицателен, массив всё равно просматривается от начала к концу. Если рассчитанный индекс оказывается меньше 0, поиск ведётся по всему массиву. Значение по умолчанию равно 0, что означает, что просматривается весь массив.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// let letter = 'd';
// let search = alphabet.indexOf(letter);
// console.log(search); // результат с отсчетом от ноля: 3

// search = alphabet.indexOf('e');
// console.log(search); // результат с отсчетом от ноля: 4


// // 9
// // Метод at() принимает значение в виде целого числа и возвращает элемент массива с данным индексом. В качестве аргумента метод принимает положительные и отрицательные числа. При отрицательном значении отсчёт происходит с конца массива.
// // Получение элементов массива с помощью квадратных скобок по-прежнему остаётся корректным способом. Например, array[0] вернёт первый элемент. Однако, при работе с элементами в конце массива больше нет необходимости прибегать к array.length. Например, для получения последнего элемента, вместо array[array.length-1] можно вызвать array.at(-1). (Смотрите примеры ниже)

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// search = 4;
// console.log('Мы используем индекс с номером: ' + search + ' для вывода под этим номером из массива: ' + alphabet.at(search)); // результат с отсчетом от ноля: е 

// search = 2;
// console.log(`Мы используем индекс с номером: ${search} для вывода под этим номером из массива: ${alphabet.at(search)}`); //  второй вариант написания с обратными кавычками
// // результат с отсчетом от ноля: с


// // 10
// // Метод find() возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// console.log(alphabet.find((search) => search === 'd')); // d 
// console.log(alphabet.find((search) => search === 'j')); // undefined


// // 11
// // Метод reverse изменяет порядок элементов в массиве на обратный.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// console.log(alphabet.reverse()); // e d c b a


// // 12
// // Метод includes() определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

// alphabet = ['a', 'b', 'c', 'd', 'e'];
// console.log(alphabet.includes('d')); // true
// console.log(alphabet.includes('f')); // false


// // 13 метод устарел
// // Метод substr возвращает подстроку из строки (исходная строка при этом не изменяется).
// // Первый параметр задает номер символа, с которого метод начинает отрезать (учтите, что нумерация с нуля), а второй параметр - сколько символов отрезать.
// // Первый параметр может принимать отрицательные значения. В этом случае отсчет символа, с которого начинается обрезание, будет идти с конца строки. Причем последний символ имеет номер -1, предпоследний - -2 и так далее.
// // Второй параметр не является обязательным, если он не указан, то вырезаны будут все символы до конца строки.

// alphabet = 'Mozilla';
// console.log(alphabet.substr(0, 3)); // Moz
// console.log(alphabet.substr(3)); // illa


// // 14
// // Метод substring возвращает подстроку из строки (исходная строка при этом не изменяется).
// // Первый параметр задает номер символа, с которого метод начинает отрезать (учтите, что нумерация с нуля), а второй параметр - номер символа, на котором следует закончить вырезание (символ с этим номером не включается в вырезанную часть).
// // Второй параметр не является обязательным, если он не указан, то вырезаны будут все символы до конца строки.
// // Если первый параметр больше второго, тогда substring ведет себя, как будто они поменялись местами. Например, написать str.substring(3, 0) все равно что написать str.substring(0, 3).
// // Если какой-то из параметров больше, чем длина строки - он считается равным длине строки.
// // Отрицательные значения приравниваются к нулю.

// word = 'Mozilla';
// console.log(word.substring(1, 4)); // ozi
// console.log(word.substring(4)); // lla


// // 15
// // Метод split осуществляет разбиение строки в массив по указанному разделителю.
// // Разделитель указывается первым необязательным параметром. Если он не задан - вернется вся строка. Если он задан как пустые кавычки '' - то каждый символ строки попадет в отдельный элемент массива.
// // Вторым необязательным параметром можно указать максимальное количество элементов в получившемся массиве (см. примеры).

// let words = 'Mozilla-Opera-Chrome';
// word = words.split('-', 2); // удаляет все '-' и оставляет два разделенных слова
// console.log(word) // Mozilla Opera

// word = words.split('', 12); // разделяет все слова на буквы и оставляет 12 букв
// console.log(word) // (12) ['M', 'o', 'z', 'i', 'l', 'l', 'a', '-', 'O', 'p', 'e', 'r']


// // 16 метод устарел

// // Устарело: Эта возможность была удалена из веб-стандартов. Хотя некоторые браузеры по-прежнему могут поддерживать её, она находится в процессе удаления. Не используйте её ни в старых, ни в новых проектах. Страницы или веб-приложения, использующие её, могут в любой момент сломаться.

// // Метод sub() создаёт HTML-элемент <sub> (en-US), заставляющий строку отображаться подстрочным текстом (нижним индексом).

// let superText = 'надстрочный';
// let subText = 'подстрочный';

// document.write(`<h1>Вот так выглядит ${superText.sup()} текст.</h1>`);
// document.write(`<h2>Вот так выглядит ${subText.sub()} текст.</h2>`);


// // 17
// // Метод trim удаляет пробелы по краям строки. Чаще всего это нужно при вводе пользователем каких-либо значений: он может случайно налепить лишних пробелов - и наша задача очистить введенный текст от них.

// word = '        Mozilla         ';
// console.log(word.trim());


// // 18
// // Метод toLowerCase производит преобразование строки в нижний регистр (из больших букв делает маленькие). При этом возвращается новая строка, а исходная строка не меняется.

// word = 'MOZILLa';
// console.log(word.toLowerCase());


// // 19
// // Метод toUpperCase производит преобразование строки в верхний регистр (из маленьких букв делает большие). При этом возвращается новая строка, а исходная строка не меняется.

// word = 'mozillA';
// console.log(word.toUpperCase());


// // 20
// // Метод repeat() конструирует и возвращает новую строку, содержащую указанное количество соединённых вместе копий строки, на которой он был вызван.
// // Целое число от 0 до +∞: [0, +∞), определяющее число повторений строки во вновь создаваемой и возвращаемой строке.
// // Возвращаемое значение
// // Новая строка, содержащая указанное количество копий строки, для которой был вызван метод.

// // 'абв'.repeat(-1);   // RangeError
// 'абв'.repeat(0);    // ''
// 'абв'.repeat(1);    // 'абв'
// 'абв'.repeat(2);    // 'абвабв'
// 'абв'.repeat(3.5);  // 'абвабвабв' (количество будет преобразовано в целое число)
// // 'абв'.repeat(1/0);  // RangeError

// word = 'Mozilla';
// console.log(word.repeat(3));


// // 21
// // Метод replace() ищет строку для указанного значения или регулярное выражение и возвращает новую строку, где указанные значения заменяются.

// // Примечание. Если вы заменяете значение (а не регулярное выражение), будет заменен только первый экземпляр значения. Чтобы заменить все вхождения указанного значения, используйте глобальный (g) модификатор.

// // Этот метод не изменяет исходную строку.

// words = 'Mozilla лучше подходит для веб разработки';
// console.log(words.replace('Mozilla', 'Chrome'));


// // 22
// // Метод charAt возвращает символ, стоящий на указанной позиции в строке. Позиция задается параметром метода (учтите, что нумерация начинается с нуля).
// // Если указанная позиция больше позиции последнего символа - вернется пустая строка.
// word  = 'Mozilla';
// console.log(word.charAt(3)); // отсчет как обычно с 0: i


// // 23
// // Метод slice возвращает подстроку из строки (исходная строка при этом не изменяется).
// // Первым параметром указывается номер символа строки, с которого начинается вырезание, а вторым параметром - номер символа, на котором закончится вырезание (при этом символ с этим номером не включится в вырезанную часть).
// // Второй параметр не является обязательным. Если его не указать - подстрока возьмется с указанного в первом параметре символа до конца строки.
// // Второй параметр также может принимать отрицательные значения. В этом случае отсчет символа, на котором закончится обрезание, начинается с конца строки. Причем последний символ имеет номер -1, предпоследний - -2 и так далее.
// // К примеру, если написать slice(1, -1), то вырезанная часть возьмется с первого символа включительно по последний не включая его. Если вам нужно включить и последний символ - нужно просто не задавать второй параметр для slice, вот так: slice(1).
// // Если второй параметр меньше первого - возвратится пустая строка.

// word = 'Mozilla';
// console.log(word.slice(2, -1));


// // 24
// // Метод indexOf осуществляет поиск подстроки (указывается первым параметром) в строке.
// //Метод вернет позицию первого совпадения, а если оно не найдено, то вернет -1.
// // Вторым параметром (он необязателен) можно передать номер символа, откуда следует начинать поиск.
// // Метод чувствителен к регистру символов.

// words = 'Mozilla Opera Chrome';
// console.log(words.indexOf('Chrome')); // 14 символов до Chrome


// document.write('Во всем разобрался, осталось запомнить))')

// task 1
let html = "";
let newMessage = document.querySelector(".newMessage");
let button = document.querySelector(".button");
function addMessage(){
    
    let name = document.querySelector(".addName").value;
    let time = new Date;
    let message = document.querySelector(".addMessage").value;
    if (newMessage.classList.contains("topNone")){
        newMessage.classList.remove("topNone")
    }
    html = `
    <div class="post">
            <label for="">Name:</label>
            <div class="name">${name}</div>
            <label for="">Time:</label>
            <div class="time">${time}</div>
        <label for="">Message:</label>
        <div class="message">${message}</div>
    </div>`;
newMessage.innerHTML += html; 
return html;
}

button.addEventListener("click", addMessage);

// task 2
let question = document.querySelectorAll(".question");
let btnQuestion = document.querySelectorAll(".btnQuestion");
let question1 = document.getElementsByName("question1");
let question2 = document.getElementsByName("question2");
let question3 = document.getElementsByName("question3");
let answer = document.querySelector(".answer");

btnQuestion[0].addEventListener("click", function(){    
    question[1].classList.remove("topNone");
})
btnQuestion[1].addEventListener("click", function(){
    question[2].classList.remove("topNone");
})
btnQuestion[2].addEventListener("click", () => {
    if (question1[2].checked && question2[1].checked && question3[2].checked) {
        answer.innerHTML = "В точку!";
    } else {
        answer.innerHTML = "Я мог бы сделать подсказку с количеством не правильных ответов, но это было бы слишком просто! Так что гадайте!!";
    }
})

// task 3

let items = document.querySelectorAll('.flex-nav');

function example(selector){
    items.forEach(item =>{
        item.addEventListener('click', (e) => {
            let attr = e.target.parentNode.getAttribute('data-name');
            let text = e.target.innerText;
            let parent = e.target.parentNode.parentNode;
            let box = parent.querySelector('[data-box]');

            if(box.hasAttribute('class')){
                box.removeAttribute('class');
            }
        
            if(!box.classList.contains(text)){
                box.classList.add(text); 
            }
        }); 
    });
    
};
example(items);

